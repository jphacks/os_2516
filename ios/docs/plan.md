# iOS実装計画（WIP）

## 開発範囲と前提
- 対象はiOSクライアント。サーバーの詳細仕様は随時反映するが、現状は `/game`・WebSocket・`/result` フローを前提とする。
- マップに表示するスポットは当面固定値。将来は `/game` から取得したリストに差し替える。

## フェーズ構成
1. **基盤整備**  
   - ディレクトリ構成・DIコンテナ雛形（完了済み）  
   - `NetworkService`・`LocationService` のプロトコル定義
2. **バトル画面強化**  
   - レーダーUIプロトタイプ（固定データ）  
   - 詠唱／ランニングゲージのアニメーションとハプティクス反応  
   - ステータスカードの視覚演出改善
3. **センサー・測位**  
   - CoreMotion + Pedometer を用いた走行判定のモック → 実端末検証  
   - UWB（Nearby Interaction）で距離・方角を取得する検証コード  
   - 非対応端末向けfallback（GPS＋コンパス）案の調査
4. **マップ画面**  
   - 固定POI表示（`MapView`＋`Marker`）  
   - `/game` レスポンスを読み込むためのデータモデル・APIクライアントの下準備  
   - バトル参加可能距離の判定とUIフィードバック（参加ボタンなど）
5. **認証基盤**  
   - メールアドレス＋パスワードのサインインを実装し、取得したJWTの保存・更新ポリシーを整える  
   - 認証状態をアプリ全体で共有する仕組みを整える（`DI/` でサービスを注入）
6. **演出**  
   - ハプティクスプリセット（攻撃／被弾／詠唱完了）  
   - サウンド再生インフラ（素材は後日差し替え）
7. **品質保証**  
   - BattleViewModel・MapViewModel のユニットテスト雛形  
   - 将来の通信モックに備えた`NetworkService`のテストダブル整備

## タスク割り当てドラフト
| 担当 | 主タスク | 補足 |
| ---- | -------- | ---- |
| Aさん | バトルUI拡張 | レーダー、ステータスカード、詠唱ボタン |
| Bさん | センサー処理 | ランニング判定・UWB検証 |
| Cさん | ネットワーク基盤 | `NetworkService`プロトコル、WebSocketラッパー、認証トークン連携 |
| Dさん | マップ画面 | POI表示・参加ボタン・`/game`連携の型定義 |
| 全員 | 演出整備 | ハプティクス／サウンド検証と適用 |

## 保留中の確認事項
- ランニング判定のしきい値（速度・距離・更新間隔）
- UWB未対応端末をどう扱うか（参加不可／近似推定で代替）
- ハプティクス・サウンド素材の調達元と時期
- レーダーUIの最終的なビジュアル（色・アニメーション）
- メール・パスワード認証でのセッション維持方法（リフレッシュのタイミング）

不明点が固まり次第、本ファイルを更新する。

---

## バックエンド連携計画（/game → WebSocket → /result）

### 想定フロー
1. `/game` で戦闘スポットの一覧・セッション情報を取得。  
2. 端末の現在地と照合し、参加可能距離内に入ったらセッション参加ボタンを表示。  
3. 参加時にWebSocketへ接続。初回メッセージで参加者の `HP/MP/name` を共有。  
4. 以降は `game-event` メッセージで行動・経過時間・HP変動などを双方向に送受信。  
5. バトルが終了したら `end` フラグを送信。  
6. `/result` を叩いて戦闘結果を取得し、リザルト画面に反映。

### 段階的タスク
1. **API仕様ドラフト**  
   - `/game` レスポンス（スポットID、座標、推奨参加人数など）のフィールド案を作成。  
   - WebSocket初回メッセージ（参加者リスト）と `game-event` のJSON構造を整理。  
   - `end` フラグおよび `/result` レスポンス（勝敗、ダメージログ等）の要件定義。
2. **iOSクライアント準備**  
   - `/game` のDTOとAPIクライアントスタブを `Application/DTOs`・`Infrastructure/Network` に追加。  
   - セッション参加判定ロジック（距離計算、UIバインディング）を Map/Battle 各 ViewModel に組み込む。  
   - WebSocket接続管理クラスのインターフェース（接続、送信、受信、再接続、end発報）を用意。  
   - メール・パスワード認証フローを実装し、取得トークンをサーバーAPI／WebSocket初回送信に添付する。
3. **イベントハンドリング統合**  
   - `game-event` を受信して BattleState に反映するマッピング処理。  
   - HP/MPや時間情報の整合性チェック、ログ保存（デバッグ用）機能。  
   - 送信側はUI操作（攻撃、詠唱完了など）から `game-event` を生成して送る。
4. **リザルト表示**  
   - `/result` レスポンスDTOの作成。  
   - 戦闘終了時の画面遷移＆再戦フロー。  
   - Endフラグ送信失敗時のリトライポリシー。
5. **エラー・再接続対応**  
   - WebSocket切断時のリカバリ（自動再接続、UI通知）。  
   - `/game` や `/result` のAPI失敗時のリトライ／フォールバック。  
   - `end` フラグの二重送信や再接続時の整合性チェック。
6. **テスト・検証**  
   - ローカルモックサーバーを用いた疎通テスト。  
   - 位置偽装／遅延シミュレーションによる耐性確認。  
   - プロトコル変更を追跡するドキュメント（このファイル or `docs/` 追加資料）を更新。

### 未確定事項（要確認）
- `/game` レスポンスの詳細項目（例：推奨人数、開催時間など）  
- `game-event` のバリエーション（攻撃種別、バフ／デバフ、モーションID 等）  
- `/result` の出力項目と保存先、リプレイ機能の要否  
- メール・パスワード認証で得たトークンの検証・保存・更新をバックエンドでどう扱うか  
- ラグ補正や時刻同期の実装有無

仕様が更新された段階で、上記タスクをチームに割り振り再見積もりする。
